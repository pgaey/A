package com.kh.chap02_abstractAndInterface.part02_sushi.mode.vo;
/*
 * 인터페이스
 * 
 * [ 표현법  ]
 * 접근제한타 interface 인터페이스 식별자{
 * 
 * 			상수필드
 * 
 * 			추상메소드
 * 			(디폴트메소드도 있긴함)
 * }
 * - 상수필드와 추상메소드만으로 이루어진 추상클래스의 변형체
 * - 인터페이스의 필드는 "무조건" 상수필드
 * - 인터페이스의 메소드는 "무조건" 추상메소드
 * 
 * - 인터페이스는 다중상속을 허용함. 
 * => 메소드가 겹치더라도 최종 구현 부분은 실제 구현클래스에서 기술하기 떄문에 문제가 없음!!!!!
 * 
 *  - "무조건" 구현해야하는게 있을 경우 인터페이스 틀만 만들어주고 상속하게 만듬!!!! => 오버라이딩
 *  
 *  - 추상크래스보다 강한 규칙성, 강제성을 가진다.
 * 
 * 1. 공통점
 * 
 * - 객체 생성은 불가능하지만, 참조변수로 사용이 가능함(다형성을 적용할 수 있다)
 * - 추상메소드를 가지고 있었을 경우 상속받는 클래스에서 추상메소드를 오버라이딩하도록 강제한다.
 * 
 * 2. 차이점
 * - 추상클래스 : 클래스 멤버로, 일반필드, 일반메소드를 가지고 있는게 가능함
 * 				추상메소드는 있어도 그만 없어도 그만 abstract키워드를 통해 정의함
 * 
 * - 인터페이스 : 모든 필드는 다 상수 필드, 특정한 경우를 제외하고 모든 메소드를 추상메소드로 정의해야함!
 * 
 * => 존재하는 목적이 다름
 * 추상클래스는 추상클래스를 상속받아서 필드, 메소드를 재사용하고 클래스를 확장하기 위한 용도
 * 인터페이스는 클래스의 기능(메소드) 구현을 강제할 용도로 사용!!!!
 * 
 * 
 */

public interface JapaneseFoodI {

	// 인터페이스 내부에서는 무조건 상수필드와 추상메소드만 정의가 가능하므로, 접근제한자, 예약어 생략 가능
	
	
	/*public ststic final */int num = 10;
	
	/*public abstract*/void haveLunch();
	void haveDinner();
	
	// => 인터페이스의 모든 필드들은 암묵적으로 public static final
	// => 인터페이스의 모든 메소드들은 암묵적으로 public abstract
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
}
